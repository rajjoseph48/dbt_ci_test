name: dbt CI Pipeline

on:
  pull_request:
    branches: [main]
    paths:
      - 'models/**'
      - 'tests/**'
      - 'macros/**'
      - 'dbt_project.yml'
      - 'packages.yml'
  push:
    branches: [main]

env:
  DBT_PROFILES_DIR: ${{ github.workspace }}

permissions:
  contents: read
  actions: read
  pull-requests: write

jobs:
  dbt_test:
    runs-on: ubuntu-latest
    name: dbt Test & Build
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: ecommerce
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    
    strategy:
      matrix:
        dbt-target: [dev]
        
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          
      - name: Setup dbt profile
        run: |
          mkdir -p ~/.dbt
          cp profiles.yml ~/.dbt/profiles.yml
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Install dbt packages
        run: |
          echo "üì¶ Installing dbt packages..."
          dbt deps 2>&1 | tee dbt_deps.log
        
      - name: Debug dbt connection
        run: |
          echo "üîå Testing dbt connection..."
          dbt debug --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_debug.log
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Download main branch artifacts (for state comparison)
        if: github.event_name == 'pull_request'
        uses: dawidd6/action-download-artifact@v6
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: dbt_ci.yml
          branch: main
          name: dbt-artifacts-dev
          path: ./state/
          if_no_artifact_found: ignore
        continue-on-error: true
          
      - name: Load seed data (state-aware for PRs)
        if: github.event_name == 'pull_request'
        run: |
          if [ -d "./state/target" ]; then
            echo "üå± Checking for new or modified seed files..."
            dbt ls --select state:modified --state ./state/target/ --resource-type seed --quiet 2>/dev/null | tee dbt_modified_seeds.log || echo "No modified seeds found"
            
            echo "üîç Checking for models that might need seed dependencies..."
            dbt ls --select +state:modified+ --state ./state/target/ --resource-type model --quiet 2>/dev/null | tee dbt_modified_models_with_deps.log || echo "No modified models found"
            
            # Check if any of the models to be built depend on seeds
            needs_seeds=false
            required_seeds=""
            while IFS= read -r model; do
              # Skip empty lines and lines that don't look like model names
              if [ -n "$model" ] && [[ "$model" =~ ^[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+\.[a-zA-Z0-9_]+$ ]]; then
                # Check if this model has seed dependencies
                seed_deps=$(dbt ls --select +$model --resource-type seed --quiet 2>/dev/null || true)
                if [ -n "$seed_deps" ]; then
                  echo "üì¶ Model $model depends on seeds: $seed_deps"
                  needs_seeds=true
                  # Collect unique seed names
                  for seed in $seed_deps; do
                    if [[ ! "$required_seeds" =~ "$seed" ]]; then
                      required_seeds="$required_seeds $seed"
                    fi
                  done
                fi
              fi
            done < dbt_modified_models_with_deps.log
            
            if [ -s dbt_modified_seeds.log ] || [ "$needs_seeds" = true ]; then
              if [ -s dbt_modified_seeds.log ]; then
                echo "üì¶ Loading modified seeds:"
                # cat dbt_modified_seeds.log
                # Run only the modified seeds
                modified_seeds=$(cat dbt_modified_seeds.log | tr '\n' ' ')
                if [ -n "$modified_seeds" ]; then
                  dbt seed --target ${{ matrix.dbt-target }} --select $modified_seeds 2>&1 | tee dbt_seed_modified.log
                fi
              fi
              if [ "$needs_seeds" = true ] && [ -n "$required_seeds" ]; then
                echo "üì¶ Loading seeds needed by modified models: $required_seeds"
                # Run only the required seeds (remove duplicates and extra spaces)
                unique_seeds=$(echo $required_seeds | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/[[:space:]]*$//')
                if [ -n "$unique_seeds" ]; then
                  dbt seed --target ${{ matrix.dbt-target }} --select $unique_seeds 2>&1 | tee dbt_seed_dependencies.log
                fi
              fi
            else
              echo "‚úÖ No seed changes or dependencies detected"
            fi
          else
            echo "‚ö†Ô∏è No previous state found, loading all seeds..."
            dbt seed --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_seed_all.log
          fi
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Load all seed data (main branch)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "üå± Loading all seeds on main branch..."
          dbt seed --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_seed_main.log
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Run dbt models (state-aware for PRs)
        if: github.event_name == 'pull_request'
        run: |
          if [ -d "./state/target" ]; then
            echo "üìä Running modified models and downstream dependencies..."
            echo "State directory contents:"
            ls -la ./state/ || echo "No state directory found"
            echo "Target directory contents:"
            ls -la ./state/target/ || echo "No target directory found"
            
            echo "üîç Checking manifest.json:"
            if [ -f "./state/target/manifest.json" ]; then
              echo "‚úÖ manifest.json exists"
              ls -la ./state/target/manifest.json
            else
              echo "‚ùå manifest.json missing"
            fi
            
            echo "üß™ Testing dbt ls with state first:"
            dbt ls --select +state:modified+ --state ./state/target/ 2>&1 | tee dbt_ls_output.log
            ls_exit_code=$?
            echo "dbt ls exit code: $ls_exit_code"
            # echo "dbt ls output:"
            # cat dbt_ls_output.log
            
            echo "üîç Debugging: What models are detected as modified?"
            dbt ls --select state:modified --state ./state/target/ 2>&1 | tee dbt_modified_only.log
            # echo "Modified models only:"
            # cat dbt_modified_only.log || echo "No modified models detected"
            
            echo "üîç Checking all available models:"
            dbt ls --resource-type model 2>&1 | tee dbt_all_models.log
            # echo "All models in project:"
            # cat dbt_all_models.log
            
            if [ $ls_exit_code -eq 0 ]; then
              echo "‚úÖ State comparison works, running dbt run..."
              echo "üöÄ Executing: dbt run --target ${{ matrix.dbt-target }} --select +state:modified+ --state ./state/target/"
              
              # Run dbt with explicit output flushing and timeout
              timeout 300 dbt run --target ${{ matrix.dbt-target }} --select +state:modified+ --state ./state/target/ 2>&1 | tee dbt_run_output.log
              run_exit_code=$?
              
              echo "üîç dbt run exit code: $run_exit_code"
              # echo "üìä Final dbt run log content:"
              # cat dbt_run_output.log | tail -20
            else
              echo "‚ùå State comparison failed in dbt ls, showing error details:"
              cat dbt_ls_output.log
              run_exit_code=1
            fi
            
            # If state comparison fails, fallback to running all models
            if [ $run_exit_code -ne 0 ]; then
              echo "‚ö†Ô∏è State comparison failed, falling back to running all models..."
              dbt run --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_run_fallback.log
              # Copy fallback log to main output log for consistency
              cp dbt_run_fallback.log dbt_run_output.log
              run_exit_code=$?
            fi
          else
            echo "‚ö†Ô∏è No previous state found, running all models..."
            dbt run --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_run_no_state.log
            # Copy to main output log for consistency
            cp dbt_run_no_state.log dbt_run_output.log
            run_exit_code=$?
          fi
          
          # Output already shown via tee, skip duplicate display
          
          # Save key information for PR comment (only if successful)
          if [ $run_exit_code -eq 0 ]; then
            echo "## dbt Run Results" > dbt_run_summary.md
            echo "" >> dbt_run_summary.md
            
            # Extract model run results
            if grep -q "Completed successfully" dbt_run_output.log; then
              MODELS_RUN=$(grep -c "OK created" dbt_run_output.log || echo "0")
              echo "‚úÖ **Models Built**: $MODELS_RUN" >> dbt_run_summary.md
              
              # List specific models that were built
              echo "" >> dbt_run_summary.md
              echo "**Models Created:**" >> dbt_run_summary.md
              grep "OK created" dbt_run_output.log | sed 's/.*OK created /- /' >> dbt_run_summary.md || echo "- (No models listed)" >> dbt_run_summary.md
            else
              echo "‚ùå **dbt run failed**" >> dbt_run_summary.md
            fi
            
            # Extract timing information
            if grep -q "Completed in" dbt_run_output.log; then
              TIMING=$(grep "Completed in" dbt_run_output.log | tail -1)
              echo "" >> dbt_run_summary.md
              echo "‚è±Ô∏è **$TIMING**" >> dbt_run_summary.md
            fi
            
            echo "" >> dbt_run_summary.md
            echo "<details>" >> dbt_run_summary.md
            echo "<summary>üìã View Full dbt Run Log</summary>" >> dbt_run_summary.md
            echo "" >> dbt_run_summary.md
            echo '```' >> dbt_run_summary.md
            cat dbt_run_output.log >> dbt_run_summary.md
            echo '```' >> dbt_run_summary.md
            echo "</details>" >> dbt_run_summary.md
          fi
          
          # Exit with the original exit code
          exit $run_exit_code
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Run all dbt models (main branch)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "üèóÔ∏è Running all models on main branch..."
          dbt run --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_run_main.log
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Run dbt tests (state-aware for PRs)
        if: github.event_name == 'pull_request'
        run: |
          if [ -d "./state/target" ]; then
            echo "üß™ Testing modified models and downstream dependencies..."
            
            echo "üîç Testing dbt ls for test selection first:"
            dbt ls --select +state:modified+ --state ./state/target/ --resource-type test 2>&1 | tee dbt_test_ls_output.log
            test_ls_exit_code=$?
            echo "dbt ls for tests exit code: $test_ls_exit_code"
            # echo "Tests that will be executed:"
            # cat dbt_test_ls_output.log
            
            if [ $test_ls_exit_code -eq 0 ]; then
              echo "‚úÖ State comparison works for tests, running selective tests..."
              timeout 300 dbt test --target ${{ matrix.dbt-target }} --select +state:modified+ --state ./state/target/ 2>&1 | tee dbt_test_output.log
              test_exit_code=$?
            else
              echo "‚ùå State comparison failed for tests, running all tests..."
              timeout 300 dbt test --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_test_output.log
              test_exit_code=$?
            fi
          else
            echo "‚ö†Ô∏è No previous state found, running all tests..."
            timeout 300 dbt test --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_test_no_state.log
            # Copy to main test output log for consistency
            cp dbt_test_no_state.log dbt_test_output.log
            test_exit_code=$?
          fi
          
          echo "üîç dbt test exit code: $test_exit_code"
          
          # Save test information for PR comment
          echo "" >> dbt_run_summary.md
          echo "## dbt Test Results" >> dbt_run_summary.md
          echo "" >> dbt_run_summary.md
          
          # Extract test results
          if grep -q "Completed successfully" dbt_test_output.log; then
            TESTS_RUN=$(grep -c "PASS" dbt_test_output.log || echo "0")
            TESTS_FAILED=$(grep -c "FAIL" dbt_test_output.log || echo "0")
            echo "‚úÖ **Tests Passed**: $TESTS_RUN" >> dbt_run_summary.md
            if [ "$TESTS_FAILED" -gt 0 ]; then
              echo "‚ùå **Tests Failed**: $TESTS_FAILED" >> dbt_run_summary.md
            fi
            
            # List specific tests that ran
            echo "" >> dbt_run_summary.md
            echo "**Tests Executed:**" >> dbt_run_summary.md
            grep -E "(PASS|FAIL)" dbt_test_output.log | sed 's/.*\(PASS\|FAIL\) /- /' >> dbt_run_summary.md || echo "- (No tests listed)" >> dbt_run_summary.md
          else
            echo "‚ùå **dbt test failed**" >> dbt_run_summary.md
          fi
          
          # Extract test timing
          if grep -q "Completed in" dbt_test_output.log; then
            TEST_TIMING=$(grep "Completed in" dbt_test_output.log | tail -1)
            echo "‚è±Ô∏è **$TEST_TIMING**" >> dbt_run_summary.md
          fi
          
          echo "" >> dbt_run_summary.md
          echo "<details>" >> dbt_run_summary.md
          echo "<summary>üß™ View Full dbt Test Log</summary>" >> dbt_run_summary.md
          echo "" >> dbt_run_summary.md
          echo '```' >> dbt_run_summary.md
          cat dbt_test_output.log >> dbt_run_summary.md
          echo '```' >> dbt_run_summary.md
          echo "</details>" >> dbt_run_summary.md
          
          # Exit with test exit code
          exit $test_exit_code
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Run all dbt tests (main branch)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "üß™ Running all tests on main branch..."
          dbt test --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_test_main.log
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Validate model documentation and tests
        run: |
          echo "üîç Checking that all models have tests and documentation..."
          
          # Get all models and handle empty results
          echo "üìã Listing all models..."
          dbt ls --resource-type model 2>&1 | tee all_models.txt || {
            echo "‚ùå Failed to list models"
            cat all_models.txt
            exit 1
          }
          
          if [ ! -s all_models.txt ]; then
            echo "‚ö†Ô∏è No models found to validate"
            exit 0
          fi
          
          echo "üìã Found models:"
          # cat all_models.txt
          
          # Check each model has tests
          echo "üìã Checking tests coverage:"
          models_without_tests=""
          while IFS= read -r model; do
            if [ -n "$model" ]; then
              test_count=$(dbt ls --resource-type test --select "$model" 2>&1 | tee "dbt_test_ls_${model//\//_}.log" | wc -l || echo "0")
              if [ "$test_count" -eq 0 ]; then
                models_without_tests="$models_without_tests $model"
                echo "‚ùå $model: No tests found"
              else
                echo "‚úÖ $model: $test_count tests"
              fi
            fi
          done < all_models.txt
          
          # Generate docs first to create manifest
          echo "üìö Generating documentation..."
          if ! dbt docs generate --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_docs_generate.log; then
            echo "‚ùå Failed to generate documentation"
            echo "Documentation generation logs:"
            cat dbt_docs_generate.log
            exit 1
          fi
          
          # Check for manifest file
          if [ ! -f "target/manifest.json" ]; then
            echo "‚ùå manifest.json not found after docs generation"
            exit 1
          fi
          
          # Check documentation coverage with warning-only approach
          echo "üìö Checking documentation coverage:"
          validation_output=$(python3 -c "
          import json
          import sys
          import os
          
          try:
              with open('target/manifest.json', 'r') as f:
                  manifest = json.load(f)
          except Exception as e:
              print(f'‚ùå Error reading manifest.json: {e}')
              sys.exit(1)
          
          models_without_docs = []
          models_checked = 0
          
          for node_id, node in manifest.get('nodes', {}).items():
              if node.get('resource_type') == 'model':
                  model_name = node.get('name', '')
                  description = node.get('description', '').strip()
                  models_checked += 1
                  
                  if not description:
                      models_without_docs.append(model_name)
                      print(f'‚ùå {model_name}: No description')
                  else:
                      print(f'‚úÖ {model_name}: Has description')
          
          print(f'Total models checked: {models_checked}')
          
          if models_without_docs:
              print(f'Models without documentation: {models_without_docs}')
              # Don't exit with error - just report
          " 2>&1)
          
          echo "$validation_output"
          
          # Check if Python script failed due to technical issues (not missing docs)
          if [ $? -ne 0 ] && echo "$validation_output" | grep -q "Error reading manifest.json"; then
            echo "‚ùå Technical error in documentation validation"
            exit 1
          fi
          
          # Warn if any models lack tests or docs
          has_warnings=false
          
          if [ -n "$models_without_tests" ]; then
            echo "‚ö†Ô∏è WARNING: The following models are missing tests:$models_without_tests"
            echo "Please add tests to ensure data quality!"
            has_warnings=true
          fi
          
          # Check if we found any models without docs from the Python script
          if grep -q "Models without documentation:" <<< "$validation_output"; then
            echo "‚ö†Ô∏è WARNING: Some models are missing documentation"
            echo "Please add descriptions to ensure proper documentation!"
            has_warnings=true
          fi
          
          if [ "$has_warnings" = true ]; then
            echo "‚ö†Ô∏è Quality checks completed with warnings - CI will continue"
          else
            echo "üéâ All models have proper tests and documentation!"
          fi
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Generate dbt docs
        run: |
          echo "üìö Generating final dbt documentation..."
          dbt docs generate --target ${{ matrix.dbt-target }} 2>&1 | tee dbt_docs_final.log
        env:
          DBT_HOST: localhost
          DBT_USER: postgres
          DBT_PASSWORD: postgres
          DBT_DATABASE: ecommerce
          DBT_SCHEMA: "pr_${{ github.event.pull_request.number || 'main' }}_analytics"
          
      - name: Upload dbt artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dbt-artifacts-${{ matrix.dbt-target }}
          path: |
            target/
            logs/
            dbt_run_summary.md
            dbt_run_output.log
            dbt_test_output.log
            
  comment_pr:
    runs-on: ubuntu-latest
    name: Comment on PR
    needs: [dbt_test]
    if: github.event_name == 'pull_request' && always()
    steps:
      - name: Download dbt artifacts
        if: needs.dbt_test.result == 'success'
        uses: actions/download-artifact@v4
        with:
          name: dbt-artifacts-dev
          path: ./artifacts/
        continue-on-error: true
        
      - name: Comment PR Success
        if: needs.dbt_test.result == 'success'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            let summaryContent = '‚úÖ **dbt CI Pipeline Passed**\n\n';
            
            try {
              // Try to read the detailed summary
              const detailedSummary = fs.readFileSync('./artifacts/dbt_run_summary.md', 'utf8');
              summaryContent += detailedSummary;
            } catch (error) {
              // Fallback to basic summary
              summaryContent += '- dbt models: ‚úÖ Built successfully (state-aware)\n- dbt tests: ‚úÖ All tests passed\n';
            }
            
            summaryContent += '\n**Schema**: `pr_${{ github.event.pull_request.number }}_analytics`\n';
            summaryContent += '**Strategy**: Only modified models + downstream dependencies\n\n';
            summaryContent += 'This PR is ready for review! üöÄ';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: summaryContent
            })
            
      - name: Comment PR Failure
        if: needs.dbt_test.result == 'failure'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '‚ùå **dbt CI Pipeline Failed**\n\n- dbt tests: ‚ùå Failed\n\nPlease check the workflow logs and fix the issues before merging. üîß'
            })
            
  cleanup:
    runs-on: ubuntu-latest
    name: Cleanup PR Schema
    needs: [dbt_test]
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    services:
      postgres:
        image: postgres:14
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: ecommerce
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - name: Cleanup PR Schema
        run: |
          PGPASSWORD=postgres psql -h localhost -U postgres -d ecommerce -c "DROP SCHEMA IF EXISTS pr_${{ github.event.pull_request.number }}_analytics CASCADE;"
        continue-on-error: true